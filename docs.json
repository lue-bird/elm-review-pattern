[{"name":"Review.Pattern.As","comment":" Forbid `... as ..variable..` patterns.\n\n@docs forbid\n\n\n## why\n\n  - `as` can quickly lead to barely readable, long patterns:\n\n        Node _ (Expression.Lambda ({ argumentPatterns, resultExpression, arrowRange } as lambda)) ->\n            x\n\n    compared to\n\n        Node _ (Expression.Lambda lambda) ->\n            let\n                { argumentPatterns, resultExpression, arrowRange } =\n                    lambda\n            in\n            x\n\n  - less syntax to learn to use right and keep in your head\n\n  - `as` in `case of` patterns can create variables with types that know less than you:\n\n        highestScoreUi ... =\n            case computeScores ... of\n                [] ->\n                    textUi \"no scores, yet\"\n\n                (head :: _) as scores ->\n                    case List.maximum scores of\n                        -- This can never happen\n                        Nothing ->\n                            -- so we'll just use the head\n                            scoreUi head\n\n                        Just highestFound ->\n                            scoreUi highestFound\n\n    compared to\n\n        highestScoreUi ... =\n            case computeScores ... of\n                [] ->\n                    textUi \"no scores, yet\"\n\n                scoresHead :: scoresTail ->\n                    scoreUi (List.Nonempty.maximum ( scoresHead, scoresTail ))\n\n    There are many more reasons for not introducing variables like that, see [`VariablesBetweenCaseOf.AccessInCases.forbid`](https://dark.elm.dmy.fr/packages/lue-bird/elm-review-variables-between-case-of-access-in-cases/latest/#why).\n\n","unions":[],"aliases":[],"values":[{"name":"forbid","comment":" Forbid `... as ..variable..` patterns.\n\n    config =\n        [ Review.Pattern.As.forbid\n        ]\n\nFor example\n\n    view ({ windowSize } as model) =\n        Html.text \"Hello!\"\n\nwill be fixed to\n\n    view model =\n        let\n            { windowSize } =\n                model\n        in\n        Html.text \"Hello!\"\n\nThis fix doesn't try to merge this destructuring into existing lets.\nAdding [`jfmengels/elm-review-simplify`](https://dark.elm.dmy.fr/packages/jfmengels/elm-review-simplify/latest)\nwill do this for you.\n\n","type":"Review.Rule.Rule"}],"binops":[]},{"name":"Review.Pattern.Record","comment":" Forbid `{ field, ... }` record patterns.\n\n@docs forbid\n\n\n## why\n\n  - Readability and error prone-ness: Similar to exposing from an import, it becomes hard to follow where a certain value originated from\n\n        checkForConcatOnMap { nodeRange, firstArg } =\n            case toSpecificCall ( \"List\", \"map\" ) firstArg of\n                Just { fnRange } ->\n                    let ...\n                    in\n                    Fix.replaceByExpression nodeRange firstArg\n                        ++ Fix.replace fnRange \"List.concatMap\"\n\n                Nothing ->\n                    Nothing\n\n    Since `fnRange`, `nodeRange` and `firstArg` could have all come from either call,\n    it's really hard to trace their origin without jumping around in your code.\n\n        checkForConcatOnMap concatCall =\n            case toSpecificCall ( \"List\", \"map\" ) concatCall.firstArg of\n                Just mapCall ->\n                    let ...\n                    in\n                    Fix.replaceByExpression concatCall.nodeRange concatCall.firstArg\n                        ++ Fix.replace mapCall.fnRange \"List.concatMap\"\n\n                Nothing ->\n                    Nothing\n\n    Here it's _always_ very clear what thing a field refers to. Don't you agree this is much easier to understand?\n\n  - less syntax to learn to use right and keep in your head\n\n  - Name clashes: Using record destructuring relies on the assumption that no values\n    with the same name will _ever_ in the lifetime of this file be introduced.\n\n        module Ui exposing (icon)\n\n        icon { image, style } =\n            ...\n\n    future iteration\n\n        module Ui exposing (icon, image)\n\n        image { proportions, url } =\n            ...\n\n        icon { image, style } =\n            ...\n\n    Ok, we have to change this one completely unrelated field into a record access.\n    That's not too bad.\n\n        module Ui exposing (icon, image)\n\n        image { proportions, url } =\n            ...\n\n        icon ({ style } as config) =\n            ...\n\n    future iteration\n\n        module Ui exposing (icon, image, url)\n\n        image { proportions, url } =\n            ...\n\n        icon ({ style } as config) =\n            ...\n\n        url { path, openInNewTab } =\n            ...\n\n    Oh well, another clash\n\n        module Ui exposing (icon, image, url)\n\n        image ({ proportions } as config) =\n            ...\n\n        icon ({ style } as config) =\n            ...\n\n        url { path, openInNewTab } =\n            ...\n\n    This mixed use of record access and record destructuring is quite ugly I'd say.\n    Maybe just use record access consistently so you don't have these problems?\n\n  - Scalability: You can't really use record destructuring anywhere except at the most outer argument/let level\n    because the field names quickly lose context and introduce name clashes.\n\n        checkForConcatOnMap { nodeRange, firstArg } =\n            case toSpecificCall ( \"List\", \"map\" ) firstArg of\n                Just { fnRange, nodeRange } ->\n                    let ...\n                    in\n                    Fix.replaceByExpression nodeRange nodeRange -- well...\n                        ++ Fix.replace fnRange \"List.concatMap\"\n\n                Nothing ->\n                    Nothing\n\n","unions":[],"aliases":[],"values":[{"name":"forbid","comment":" Forbid `{ field, ... }` record patterns.\n\n    config =\n        [ Review.Pattern.Record.forbid\n        ]\n\nFor example\n\n    a ({ field } as record) =\n        f field record\n\nwill be fixed to\n\n    a record =\n        f record.field record\n\nPatterns without `as` will not get an auto-fix, so either manually apply this change\nor add a temporary `as`.\n\n","type":"Review.Rule.Rule"}],"binops":[]}]